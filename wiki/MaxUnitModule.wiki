#summary Unit Testing for BlitzMax

= Introduction =

Unit testing is a way to validate that a particular section of code works properly.

The Max Unit module makes it easy to implement your tests with the least possible fuss. The latest version is available from Downloads.

==An Example==
Let's go through a quick example to show how this unit testing can work.

First, the code we want to test. Something very simple. A method which performs a calculation.
{{{
SuperStrict

Type TMyController

	' add two numbers and multiply the result by 2 '
	Method DoCalculation:Int(x:Int, y:Int)

		Return x + y * 2
	
	End Method

End Type
}}}
The observant amongst you will notice that the calculation is wrong. As it is intended. We'll write our test to prove it doesn't work, then we can fix the code and see that the test passes.
{{{
SuperStrict

Framework BaH.MaxUnit

Import "controller.bmx" ' the file containing the above Type '

New TTestSuite.run()

Type ControllerTest Extends TTest

	Field controller:TMyController

	Method setup() { setup }
		controller = New TMyController
	End Method

	Method testDoCalculation() { test }
	
		Local result:Int = controller.DoCalculation( 1, 1 )
		Local expectedResult:Int = 4   '  1 + 1 = 2 * 2 = 4 '
		
		assertEqualsI(expectedResult, result)
	
	End Method

End Type
}}}
Running this test, results in the following output :
{{{
[0] F

There was 1 failure:
1) testDoCalculation
    assertEqualsI() :  expected:<4> but was:<3>


FAILURES!!!
Tests run: 1,  Failures: 1,  Errors: 0
Time: 0.3

Process complete
}}}
As you expected, the test failed!

Notice how Max Unit provides you with information that might help you track down the bug.

We'll quickly fix the code and run it again.

This is the calculation line as it should be:
{{{
		Return (x + y) * 2
}}}
And the result of running the test now :
{{{
[0] .
OK (1 test)
Time: 0.2

Process complete
}}}
Much better!
The test passes, and we can now sleep well at night.

==How It Works==
Max Unit uses BlitzMax's new Reflection framework to make writing your tests easier. This allows us to concentrate writing tests than the code that runs them.

The key steps to building a test are
  * extend your test Type from TTest - Max Unit will automatically run tests for all Types that extend TTest.
  * tag your methods with {setup}, {teardown}, or {test} - These are metadata tags that tell Max Unit what a particular method does. You can have one setup, one teardown, and as many test methods as you like.
  * run the TTestSuite, and wait for the results.

A setup method is run *before* each test method. A teardown method is run *after* each test method. These are optional. You can use them for setting up and clearing any data that you use during your test.

A tag is a set of curly brackets with some text between them, after your Method definition. Like this :
{{{
	Method testDoCalculation() { test }
}}}
If you haven't used them before in BlitzMax, it does look a bit strange. But it *does* compile. ;-)

Now, off you go and get testing!